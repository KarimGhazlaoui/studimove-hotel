const mongoose = require('mongoose');

const ClientSchema = new mongoose.Schema({
  // üÜï AJOUT: R√©f√©rence vers l'√©v√©nement
  eventId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Event',
    required: [true, 'L\'ID de l\'√©v√©nement est requis'],
    index: true
  },

  firstName: {
    type: String,
    required: [true, 'Le pr√©nom est requis'],
    trim: true,
    maxlength: [50, 'Le pr√©nom ne peut pas d√©passer 50 caract√®res']
  },

  lastName: {
    type: String,
    required: [true, 'Le nom est requis'],
    trim: true,
    maxlength: [50, 'Le nom ne peut pas d√©passer 50 caract√®res']
  },

  phone: {
    type: String,
    required: [true, 'Le t√©l√©phone est requis'],
    trim: true,
    maxlength: [20, 'Le t√©l√©phone ne peut pas d√©passer 20 caract√®res']
  },

  email: {
    type: String,
    trim: true,
    lowercase: true,
    maxlength: [100, 'L\'email ne peut pas d√©passer 100 caract√®res']
  },

  // üÜï AJOUT: Sexe pour l'assignation des chambres
  gender: {
    type: String,
    required: [true, 'Le sexe est requis'],
    enum: {
      values: ['Homme', 'Femme', 'Autre'],
      message: 'Sexe invalide'
    }
  },

  clientType: {
    type: String,
    enum: {
      values: ['VIP', 'Influenceur', 'Staff', 'Groupe', 'Solo'],
      message: 'Type de client invalide'
    },
    default: 'Solo'
  },

  groupName: {
    type: String,
    trim: true,
    maxlength: [100, 'Le nom du groupe ne peut pas d√©passer 100 caract√®res']
  },

  groupSize: {
    type: Number,
    default: 1,
    min: [1, 'La taille du groupe doit √™tre au moins de 1'],
    max: [50, 'La taille du groupe ne peut pas d√©passer 50']
  },

  // üÜï AJOUT: Relation de groupe pour la mixit√©
  groupRelation: {
    type: String,
    enum: ['Famille', 'Couple', 'Amis', 'Coll√®gues', 'Autre'],
    default: 'Amis'
  },

  assignedHotel: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Hotel'
  },

  // üÜï AJOUT: Assignation de chambre
  roomAssignment: {
    roomId: String, // ID g√©n√©r√© pour la chambre assign√©e
    roomType: String, // Standard, Suite, etc.
    roomCapacity: Number,
    roommates: [{
      clientId: { type: mongoose.Schema.Types.ObjectId, ref: 'Client' },
      name: String,
      gender: String
    }]
  },

  status: {
    type: String,
    enum: {
      values: ['En attente', 'Confirm√©', 'Assign√©', 'Pr√©sent', 'Absent', 'Annul√©'],
      message: 'Statut invalide'
    },
    default: 'En attente'
  },

  preferences: {
    roomType: String,
    specialRequests: String,
    accessibility: Boolean,
    dietary: [String] // V√©g√©tarien, Sans gluten, etc.
  },

  paymentInfo: {
    status: {
      type: String,
      enum: ['Non pay√©', 'Acompte', 'Pay√©', 'Rembours√©'],
      default: 'Non pay√©'
    },
    amount: { type: Number, default: 0 },
    vipSupplement: { type: Number, default: 0 }
  },

  notes: {
    type: String,
    trim: true,
    maxlength: [500, 'Les notes ne peuvent pas d√©passer 500 caract√®res']
  },

  emergencyContact: {
    name: String,
    phone: String,
    relation: String
  },

  // Metadata
  source: {
    type: String,
    enum: ['Manuel', 'CSV', 'API', 'Web'],
    default: 'Manuel'
  },

  importBatch: String, // ID du lot d'import pour tra√ßabilit√©

}, {
  timestamps: true
});

// üÜï Index compos√©s pour optimiser les recherches par √©v√©nement
ClientSchema.index({ eventId: 1, status: 1 });
ClientSchema.index({ eventId: 1, clientType: 1 });
ClientSchema.index({ eventId: 1, gender: 1 });
ClientSchema.index({ eventId: 1, groupName: 1 });
ClientSchema.index({ eventId: 1, assignedHotel: 1 });

// üÜï CONTRAINTE: T√©l√©phone unique par √©v√©nement (pas globalement)
ClientSchema.index({ eventId: 1, phone: 1 }, { unique: true });

// M√©thodes virtuelles
ClientSchema.virtual('fullName').get(function() {
  return `${this.firstName} ${this.lastName}`;
});

ClientSchema.virtual('isVIP').get(function() {
  return this.clientType === 'VIP';
});

ClientSchema.virtual('canBeMixed').get(function() {
  return this.clientType === 'VIP' || this.clientType === 'Influenceur' || 
         (this.groupRelation === 'Famille' || this.groupRelation === 'Couple');
});

ClientSchema.virtual('isAssigned').get(function() {
  return this.assignedHotel && this.roomAssignment && this.roomAssignment.roomId;
});

// M√©thodes d'instance
ClientSchema.methods.assignToRoom = function(roomData) {
  this.roomAssignment = {
    roomId: roomData.roomId,
    roomType: roomData.roomType,
    roomCapacity: roomData.capacity,
    roommates: roomData.roommates || []
  };
  this.status = 'Assign√©';
  return this.save();
};

ClientSchema.methods.unassignRoom = function() {
  this.roomAssignment = undefined;
  this.status = 'Confirm√©';
  return this.save();
};

// Middleware pre-save
ClientSchema.pre('save', function(next) {
  // Validation des groupes
  if (this.clientType === 'Groupe' && !this.groupName) {
    return next(new Error('Le nom du groupe est requis pour un client de type Groupe'));
  }
  
  if (this.clientType === 'Solo') {
    this.groupName = null;
    this.groupSize = 1;
  }
  
  next();
});

module.exports = mongoose.model('Client', ClientSchema);
